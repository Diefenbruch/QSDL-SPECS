/****************************************************************************
 * $RCSfile: tcp.pr,v $
 * $Author: jruehl $
 * $Date: 1995/04/25 11:02:58 $
 * $Revision: 1.1 $
 ****************************************************************************/

SYSTEM QTCP;

  SYNONYM MEDIUM_BUFFER Integer = 5000; /* Pufferbeschraenkung               */
  SYNONYM MEDIUM_DELAY Duration = 0;    /* IP-Arbeits- und Uebertragungszeit */
  SYNONYM MRTT Duration = (MEDIUM_DELAY * 3) + 3;
                                        /* Maximum Round Trip Time           */
  SYNONYM DEFAULT_TO Duration = (MEDIUM_DELAY * 3) + 2;
                                        /* Zeit zwischen Retransmits         */
  SYNONYM TIME_OUT Duration = MEDIUM_DELAY * 3 + 3;
                                        /* maximale Wartezeit zwischen zwei  */
                                        /* zwischen Verbindungen             */
  SYNONYM MAXNR Integer = 28000;        /* Sequenznummern von 0..MAXNR       */
  SYNONYM WINDOW_SIZE Integer = MAXNR / 2; /* Fenstergroesse                 */
  SYNONYM BUFFER_SIZE Integer = 256;  /* max. Anzahl pufferbarer     */
                                        /* gesendeter unbestaetigter Pakete  */
  SYNONYM MAX_RETRANSMIT Integer = 3;   /* nach .. unbestaetigten Sendungen  */
                                        /* wird Verbindung abgebaut          */
  SYNONYM CONNECTION_TIME Duration = EXTERNAL;
                                        /* Verbindungsdauer                  */
  SYNONYM WAIT_DELAY Duration = MEDIUM_DELAY / 2 + 1;
                                        /* maximale Wartezeit zwischen       */
                                        /* Paketsendungen		                 */
  SYNONYM DESTROY_RATE Integer = 20;    /* Fehlerrate: Verlust jedes n. Pak. */
  SYNONYM FAULT Boolean = FALSE;        /* Fehlerrate ein- und ausschalten   */
  SYNONYM STANDARD Integer = 516;       /* Standardpaket(RFC) 516 Byte gross */
  SYNONYM MAX_CONNECTIONS Integer = 256;/* Anzahl Ports die Host besitzt     */
  SYNONYM NUM_OF_CONNECTIONS Integer = EXTERNAL; /* Anzahl von Verbindungen, */
                                          /* die Lastgenerator aufbauen soll */
  SYNONYM SERVER_A_ADDRESS Integer = 111; /* Host- und Net-Id, normal 32 bit */
  SYNONYM SERVER_B_ADDRESS Integer = 112; /* Host- und Net-Id, normal 32 bit */
  SYNONYM STANDARD_TIMEOUT Integer = 10;  
      /* automatischer Abbruch falls keine Antworten mehr eintreffen         */
  SYNONYM STANDARD_TIMEOUT_ACTION  Integer= 1;  /* Aktion auf Timeout        */
  SYNONYM STANDARD_PREC Integer = 0;                     
  SYNONYM STANDARD_SECURITY Integer  = 0; /* Sicherheitsprioritaet           */
  SYNONYM NO_ACK_FLAG Boolean = FALSE;    /* Acknowlege-Flag                 */
  SYNONYM NO_PUSH_FLAG Boolean = FALSE;   /* Push-Flag                       */
  SYNONYM NO_URGENT_FLAG Boolean = FALSE; /* Urgent-Flag                     */
  SYNONYM NO_FIN_FLAG Boolean = FALSE;    /* Final-Flag                      */
  SYNONYM NO_SYN_FLAG Boolean  = FALSE;   /* Synchronisation-Flag            */
  SYNONYM NO_RESET_FLAG Boolean  = FALSE; /* Reset-Flags                     */
  SYNONYM ACK_FLAG Boolean = TRUE;        /* Acknowlege-Flag                 */
  SYNONYM PUSH_FLAG Boolean  = TRUE;      /* Push-Flag                       */
  SYNONYM FIN_FLAG Boolean = TRUE;        /* Final-Flag                      */
  SYNONYM SYN_FLAG Boolean = TRUE;        /* Synchronisation-Flag            */
  SYNONYM RESET_FLAG Boolean = TRUE;      /* Reset-Flags                     */
  SYNONYM FATAL_ERROR  Integer = 10;      /* fuehrt zu Verbindungsabbau      */
  SYNONYM DEFAULT_ERROR Integer = 1;      /* fuehrt nicht zu Verbindungsabbau*/
  SYNONYM LOAD_GENERATION_DELAY Duration = 0.1; /* Lastgenratorsteuerung     */
  
  /* SYNONYM MACH_MEDIUM_SPEED  Real = EXTERNAL;  Speedparameter fuer Datenkanal          */
  /* SYNONYM MACH_MEDIUM_SERVER  Natural = 1;     Anzahl Server fuer Medium-Maschine      */
  /* SYNONYM MACH_TCP_SPEED  Real = EXTERNAL;     Speedparameter fuer Paketetverarbeitung */
  /* SYNONYM MACH_TCP_SERVER  Natural = 1;        Anzahl Server fuer TCP-Maschine         */

  SYNTYPE IPLength = Integer CONSTANTS 0:536 ENDSYNTYPE;
    /* IPPaketgroesse := TCPPaket + 20 Bytes */
  SYNTYPE TCPLength = Integer CONSTANTS 0:STANDARD ENDSYNTYPE;
    /* minimal 0, maximal 516 Byte Nutzdaten pro TCPPaket */
  SYNTYPE PortRange = Integer CONSTANTS 0:256 ENDSYNTYPE;
  SYNTYPE WindowSize = Integer CONSTANTS 0:MAXNR ENDSYNTYPE;
  SYNTYPE BufferRange = Integer CONSTANTS 0:MEDIUM_BUFFER ENDSYNTYPE;
  SYNTYPE RetransmitRange = Integer CONSTANTS 0:BUFFER_SIZE ENDSYNTYPE;


  NEWTYPE Tcp STRUCT                      /* Felder eines TCP-Paketes:       */                 
    sp,dp,                                /* Source und Destination Port     */
    sa,da,                                /* Source und Destination Address  */
    seq,an,                               /* Sequence und Acknowledge Number */
    wnd,urgp Integer;                     /* Window Size und Urgent Pointer  */
    len,cs TCPLength;                     /* Length and Checksum             */
    syn,ack,rst,fin,urg,psh Boolean;      /* Flags s. o.                     */
  ENDNEWTYPE;
    
  NEWTYPE Ip STRUCT                       /* Felder eines IP-Paketes         */
    src,dst,                              /* Source und Destination Address  */
    prot,tos,                             /* Protection und Type of Service  */
    ttl,id,options Integer;               /* Time to live und Paket-ID       */
    len,cs IPLength;                      /* Length und Checksum             */
    df Boolean;                           /* fragmented-Flag */
    DATA Tcp;                             /* TCP-Paket                       */
  ENDNEWTYPE;

  NEWTYPE RetransmitPacket STRUCT         /* gesendete Pakete werden gespei- */
                                          /* chert, bis Ankunftbestaetigung  */
    tcp_packet Tcp;                       /* TCP-Paket                       */
    failed_retransmit Integer;            /* wie oft bereits neugesendet     */
    activ Boolean;                        /* bestaetigt/unbestaetigt         */
  ENDNEWTYPE;

  NEWTYPE ListOfRetrPackets Array         /* Liste zur Speicherung gesende-  */ 
    (RetransmitRange, RetransmitPacket)   /* ter Pakete                      */
  ENDNEWTYPE;
    
  NEWTYPE PortAddr Array                  /* Speicherung der dynamisch er-   */
    (PortRange,PId)                       /* zeugten Portprozess-IDs         */
  ENDNEWTYPE;
    
  NEWTYPE TransmitData STRUCT             /* Speicherung der noch nicht ge-  */
    len,urgp,pshp Integer;                /* deten Daten: Laenge, ... s. o.  */
    fin,urg,psh Boolean;
  ENDNEWTYPE;
    
  NEWTYPE TCBBlock STRUCT                 /* Transport Control Block: dient  */
    sp,da,dp,                             /* aktiven Ports zur Speicherung   */
    tout,toa,prec,sec,                    /* aller waehrend der Verbindung   */
    isn,iss,aaa,aar Integer;              /* benoetigten Variablen s. RFC793 */
    urg,psh Boolean;
    snd_nxt,rcv_nxt,snd_wnd,rcv_wnd,snd_una WindowSize;
  ENDNEWTYPE;
    
    SIGNAL status(Integer),close(Integer),abort(Integer),os(Integer),
           of(Integer),process_terminated(Integer),closing(Integer),
           upo(Integer,Integer,Integer,Integer,Integer),
    	   fspo(Integer,Integer,Integer,Integer,Integer,Integer,Integer),
    	   ao(Integer,Integer,Integer,Integer,Integer,Integer,Integer),
    	   aod(Integer,Integer,Integer,Integer,Integer,Integer,Integer,
    	       Integer,Boolean,Boolean),
    	   send(Integer,Integer,Boolean,Boolean,Integer,Integer),
    	   allocate(Integer,Integer),
    	   oid(Integer,Integer,Integer,Integer),
    	   del(Integer,Integer,Boolean),
    	   ter(Integer,Integer),
    	   err(Integer,Integer),
    	   stresp(Integer,Integer,Integer,Integer,Integer,Integer,
    	   	  Integer,Boolean,Integer,Integer,Integer),
    	   tcp_packet(Tcp),
    	   ip_packet(Ip);
    	   	      
   SIGNALLIST L1 = upo,fspo,ao,aod,send,allocate,close,status,abort;
     /* Signale vom Lastgenerator an den TCP-Managerprozess */
   
   SIGNALLIST L2 = os,of,oid,del,ter,err,stresp, closing;
     /* Signale von TCPPort-Prozessen an den TCP-Managerprozess */
   
   SIGNALLIST L3 = os,of,del,ter,err,stresp,closing,process_terminated;
     /* Signale vom TCP-Managerprozess an den Lastgenerator */
   		 
  BLOCK Application REFERENCED;
   
  BLOCK TCP REFERENCED;
   
  BLOCK IP REFERENCED;

  BLOCK Medium REFERENCED;
   
   CHANNEL Application
       FROM Application TO TCP WITH (L1);
       FROM TCP TO Application WITH (L2);
   ENDCHANNEL Application;
   
   CHANNEL TransportService
       FROM TCP TO IP WITH tcp_packet;
       FROM IP TO TCP WITH tcp_packet;
   ENDCHANNEL TransportService;
   
   CHANNEL Datagramm
       FROM IP TO MEDIUM WITH ip_packet;
       FROM MEDIUM TO IP WITH ip_packet;
   ENDCHANNEL Datagramm;
   
ENDSYSTEM QTCP;

BLOCK TCP;
                         
  PROCESS Manager REFERENCED;	
  PROCESS Port REFERENCED;	
     
  /* MACHINESERVICE compute_packet(Real);
    
  MACHINE TCPMachine;
     SERVER     MACH_TCP_SERVER;
     DISCIPLINE FCFS;
     OFFERS compute_packet: MACH_TCP_SPEED;
  ENDMACHINE TCPMachine;
        
  LINK serv2
       from Port to TCPMachine WITH compute_packet; */
     
  SIGNALROUTE UpperSAP
    FROM Manager TO ENV WITH (L2);
    FROM ENV TO Manager WITH (L1);
    
  SIGNALROUTE LowerSAP
    FROM Manager TO ENV WITH tcp_packet;
    FROM ENV TO Manager WITH tcp_packet;
        
  SIGNALROUTE Stream 
    FROM Manager TO Port WITH (L1), tcp_packet;
    FROM Port TO Manager WITH (L3), tcp_packet;
    
  CONNECT Application AND UpperSAP;
  CONNECT TransportService AND LowerSAP;
    
ENDBLOCK TCP;


BLOCK IP;

  SYNONYM OWN_ADDRESS Integer = 111;	   /* Host- und Net-Id, normal 32 bit */

  PROCESS Activity (1,1) REFERENCED;
    
  SIGNALROUTE UpperSAP
    FROM Activity TO ENV WITH tcp_packet;
    FROM ENV TO Activity WITH tcp_packet;
       
  SIGNALROUTE LowerSAP
    FROM Activity TO ENV WITH ip_packet;
    FROM ENV TO Activity WITH ip_packet;
       
  CONNECT TransportService AND UpperSAP;
  CONNECT Datagramm AND LowerSAP;
    
ENDBLOCK IP;

BLOCK Medium;

  PROCESS Transport (1,1) REFERENCED;
    
  /* MACHINESERVICE deliver(Real);
    
  MACHINE MediumMachine;
     SERVER     MACH_MEDIUM_SERVER;
     DISCIPLINE FCFS;
     OFFERS     deliver: MACH_MEDIUM_SPEED;
  ENDMACHINE MediumMachine;
    
  LINK serv1
       from Transport to MediumMachine WITH deliver; */

  SIGNALROUTE UpperSAP
    FROM Transport TO ENV WITH ip_packet;
    FROM ENV TO Transport WITH ip_packet;
        
  CONNECT Datagramm AND UpperSAP;
    
ENDBLOCK Medium;  


BLOCK Application;

/* SIGNAL send_init, kill;

PROCESS Quelle(0, MAX_CONNECTIONS) REFERENCED; */

PROCESS LoadGenerator(0, MAX_CONNECTIONS); 

FPAR addr Integer;

SYNONYM DATA Integer = 5000;            /* Stossweise Lastgenerierung         */
SYNONYM PORT_1 Integer = 1;
SYNONYM PORT_2 Integer = 2;

SYNTYPE TwoPorts = Integer CONSTANTS 1:2 ENDSYNTYPE;
SYNTYPE NumberOfPorts = Integer CONSTANTS 0:NUM_OF_CONNECTIONS * 2 ENDSYNTYPE;

NEWTYPE ReceiveBlock Array              /* dient dem Mitzaehlen der empfange- */
  (TwoPorts, Integer)                   /* nen Nutzdaten beim Lastgenerator   */
ENDNEWTYPE;

NEWTYPE AddressID Array                 /* dient dem Speichern der Portaddr.  */ 
  (TwoPorts, Integer)
ENDNEWTYPE;

NEWTYPE TraceBlockStructure Struct     /* Struktur zum Speichern von Tracein- */
  failed_connection,                   /* formationen: (nicht) erfolgreiche   */
  succeeded_connection Integer;        /* Verbindungen, Datendurchsatz        */
  received ReceiveBlock;
ENDNEWTYPE;

DCL sp,dp,da,name,len,prec,sec,descr,tout,aaa,aar,rcv_wnd,snd_wnd,open,
    send_to Integer;
DCL urg Boolean;
DCL trace_block TraceBlockStructure;
DCL address AddressID;
DCL counter Integer := 1;

TIMER send_init,send_fin;

START;
   
   jump1:
   DECISION counter > 2;
   (TRUE):
   (FALSE):
     TASK trace_block!received(counter) := 0,   /* Initialisierung           */
          counter := counter + 1;
     JOIN jump1;
   ENDDECISION;
      
   TASK address(PORT_1) := addr;
   TASK address(PORT_2) := NUM_OF_CONNECTIONS + addr;
   /* CREATE Quelle;              */
   SET(NOW, send_init);
   NEXTSTATE MakeConnection1;
   
   STATE MakeConnection1;
     /* Der Verbindungsaufbau des Transportprotokoll laueft so: Seite 1
        erhaelt ein Passive Open, ist also bereit, Verbindungswuensche an-
        zunehmen. Z. B. sendet ein Fileserver an alle seine Ports nach
        Inbetriebnahme ein Unspecified Passive Open, womit es nun moeglich
        ist, von aussen uber einen Port Verbindungen aufzubauen. Dies geschieht
        durch ein Active Open, d. h. das Transportprotokoll wird veranlasst,
        ein Synchronisationspaket zu senden. Geschieht dies, wird der Ver-
        bindungsaufbau im three way handshaking Verfahren abgewickelt.
        Sendet die Anwendung ein Active oder Passive Open Request an das 
        Transportprotokoll, erhaelt es von ihm einen Namen zurueck, unter dem
        die Verbindung anzusprechen ist (oid = open ID). Mit dieser ID verbin-
        det TCP bei ankommenden Paketen die Zielanwendung, bei Datenrequests
        der Anwendung weiss TCP, welcher Port angesprochen wird.             */ 
        
      INPUT send_init;
         DECISION ANY;
         ():
           OUTPUT upo (address(PORT_1),STANDARD_TIMEOUT,
                       STANDARD_TIMEOUT_ACTION,STANDARD_PREC,
                       STANDARD_SECURITY);
         ():
           OUTPUT fspo (address(PORT_1),address(PORT_2),SERVER_A_ADDRESS,
                        STANDARD_TIMEOUT, STANDARD_TIMEOUT_ACTION,
                        STANDARD_PREC, STANDARD_SECURITY);
         ():
           OUTPUT ao  (address(PORT_2),address(PORT_1),SERVER_A_ADDRESS,
                        STANDARD_TIMEOUT, STANDARD_TIMEOUT_ACTION,
                        STANDARD_PREC, STANDARD_SECURITY);
             /* hat ein Reset des Partners zur Folge, s. o., dient dem
               Testen, ob TCP bei falschem Verbindungsaufbau korrekt
               ablehnt                                                       */ 
         ENDDECISION;
         NEXTSTATE WaitForID1;
   ENDSTATE MakeConnection1;

   STATE MakeConnection2;
     /* Nach Senden des Passive Open jetzt durch ein Active Open der Partner-
        seite den Verbindungsaufbau anstossen                                */	
      INPUT send_init;
         DECISION ANY;
         ():
           OUTPUT ao  (address(PORT_2),address(PORT_1),SERVER_A_ADDRESS,
                        STANDARD_TIMEOUT, STANDARD_TIMEOUT_ACTION,
                        STANDARD_PREC, STANDARD_SECURITY);
         ():
           OUTPUT aod   (address(PORT_2), address(PORT_1), SERVER_A_ADDRESS,
                        STANDARD_TIMEOUT, STANDARD_TIMEOUT_ACTION,
                        STANDARD_PREC, STANDARD_SECURITY, DATA,
                        NO_PUSH_FLAG, NO_URGENT_FLAG); 
         ENDDECISION;
         NEXTSTATE WaitForID2;
   ENDSTATE MakeConnection2;
      
   STATE WaitForID1;
     /* nach Senden eines Open kommt entweder ein Name fuer die Transport-
        verbindung oder eine Fehlermeldung (of = Open Failure) zurueck, weil
        z. B. der angesprochene Port schon belegt ist                        */
        
      INPUT oid(name, sp,dp,da);
         TASK address(PORT_1) := name;
         SET(NOW, send_init);
         NEXTSTATE MakeConnection2;
         
      INPUT of(name);
         TASK trace_block!failed_connection := 
                     trace_block!failed_connection + 1;
         SET(NOW, send_init);
         NEXTSTATE MakeConnection1;

      INPUT send_init;
        SET(NOW, send_init);
        NEXTSTATE -;
      
   ENDSTATE WaitForID1;

   STATE WaitForID2;
     /* nach Senden eines Open kommt entweder ein Name fuer die Transport-
        verbindung oder eine Fehlermeldung (of = Open Failure) zurueck, weil
        z. B. der angesprochene Port schon belegt ist                        */
        
      INPUT oid(name, sp, dp, da);
         TASK address(PORT_2) := name;
         SET(NOW + LOAD_GENERATION_DELAY, send_init);
         NEXTSTATE WaitCompletion;
         
      INPUT of(name);
         TASK trace_block!failed_connection := 
                     trace_block!failed_connection + 1;
         OUTPUT close(name);
         SET(NOW, send_init);
         NEXTSTATE MakeConnection1;
      INPUT send_init;
        NEXTSTATE -;
        
   ENDSTATE WaitForID2;
      
   STATE WaitCompletion;
     /* Wenn der Verbindungsaufbau nicht klappt, erhaelt die Anwendung eine
        Open Failure Nachricht, sonst von beiden Partnern ein Open Success. 
        Falls im Synchronisationspaket bereits Nutzdaten enthalten waren (aod =
        Active Open with Data) koennen diese bereits empfangen werden (del)   */
      INPUT of (name);
         TASK trace_block!failed_connection := trace_block!failed_connection +1;  
         DECISION name = address(PORT_1);
         (TRUE):
            OUTPUT close(address(PORT_2));
         (FALSE):
            OUTPUT close(address(PORT_1));
         ENDDECISION;
         SET(NOW + LOAD_GENERATION_DELAY, send_init);
         NEXTSTATE MakeConnection1;
         
      INPUT send_init;
         SET(NOW + LOAD_GENERATION_DELAY, send_init);
        NEXTSTATE -;
      
      INPUT os (name);
         TASK trace_block!succeeded_connection := 
              trace_block!succeeded_connection + 1;
         DECISION open = 0;
         (TRUE):	                  /* OS des zweiten Ports abwarten ! */
            TASK open := open + 1;           
            NEXTSTATE WaitCompletion;
         (FALSE):
            SET (NOW + connection_time, send_fin);        /* Verbindungsdauer */
            TASK send_to := 1,
                 open := 0;
            SET(NOW + LOAD_GENERATION_DELAY, send_init);
            NEXTSTATE Connected;
         ENDDECISION;
         
      INPUT oid (name, sp, dp, da);
          NEXTSTATE -;
          
      INPUT del(name,len,urg);	                     /* Datenuebergabe       */
         TASK trace_block!received((name mod 2) + 1) := trace_block!received((name mod 2) + 1) + len;
         NEXTSTATE -;
         
   ENDSTATE WaitCompletion;
   
   STATE Connected;
     /* Handling der aktiven Verbindung: ankommende Nutzdaten werden mitge-
        traced, falls send_init-Signal von OnOff-Quelle kommt, wird ein
        Datenpaket an einen der beiden Verbindungspartner gesendet, falls der
        Timer send_fin feuert, wird die Verbindung ordentlich abgebaut.      */
        
      INPUT del(name,len,urg);	                     /* Datenuebergabe       */
         TASK trace_block!received((name mod 2) + 1) := trace_block!received((name mod 2) + 1) + len;
         OUTPUT allocate (name, len); 
         NEXTSTATE Connected;
         
      INPUT send_init;
         DECISION ANY;	         /* Daten werden abwechselnd an Port 1 bzw.   */
         (): 
            TASK send_to:=address(PORT_2);	 /* an Port 2 gesendet !      */
         ():
            TASK send_to:=address(PORT_1);
         ENDDECISION;
         OUTPUT send(send_to, DATA, NO_PUSH_FLAG, NO_URGENT_FLAG,
                     STANDARD_TIMEOUT, STANDARD_TIMEOUT_ACTION);
         SET(NOW + LOAD_GENERATION_DELAY, send_init);
         NEXTSTATE Connected;
         
      INPUT send_fin;
         OUTPUT status(address(PORT_1));
         OUTPUT close (address(PORT_1));
         NEXTSTATE Connected;
        
      INPUT closing(name);
         OUTPUT close (address(PORT_2));
         NEXTSTATE WaitDisconnection;
         
      INPUT err(name,descr);
         DECISION descr;
         (FATAL_ERROR):
            OUTPUT abort(address(((name + 1) mod 2) + 1));
            NEXTSTATE WaitDisconnection;
         (DEFAULT_ERROR):	         /* weitere Fehlerbehandlungen !      */
         ENDDECISION;
         NEXTSTATE Connected;
      
      INPUT stresp(name,dp,da,rcv_wnd,snd_wnd,aaa,aar,urg,prec,sec,tout);
         NEXTSTATE Connected;
            
   ENDSTATE Connected;
   
   STATE WaitDisconnection;
     /* Verbindungsabbauphase: Die Anwendung wartet, bis beide Ports wieder
        im Zustand CLOSED sind und dies dur ter (terminated) mitgeteilt haben */

      INPUT del(name,len,urg);	                     /* Datenuebergabe       */
         TASK trace_block!received((name mod 2) + 1) := trace_block!received((name mod 2) + 1) + len;
         OUTPUT allocate (address((name mod 2) + 1), len); 
         NEXTSTATE -;

      INPUT err(name, descr);
        NEXTSTATE -;
        
      INPUT send_init;
        NEXTSTATE -;
      
      INPUT ter (name,descr);
         TASK trace_block!succeeded_connection := 
                          trace_block!succeeded_connection + 1,
              open := open + 1;
         DECISION open = 2;
         (TRUE):	        /* beide Ports haben Verbindung abgebaut      */
            TASK open := 0;
            SET(NOW + LOAD_GENERATION_DELAY, send_init);
            NEXTSTATE MakeConnection1;
         (FALSE):	         /* Warten auf Endemeldung des zweiten Ports  */
            NEXTSTATE WaitDisconnection;
         ENDDECISION;
   ENDSTATE WaitDisconnection;
   
ENDPROCESS LoadGenerator;       

/****************************************************************************
 * $RCSfile: ApplicationManager,v $
 * $Author: jruehl $
 * $Date: 1995/04/25 11:03:38 $
 * $Revision: 1.4 $
 ****************************************************************************/

PROCESS ApplicationManager (1, 1);
/* Aufgabe dieses Prozesses ist die dynamische Erzeugung von Lastprozessen, 
   die jeweils 2 Ports mit Daten versorgen                                   */

SYNONYM FIRST_PROCESS_ID Integer = 1;
DCL last_process_id INTEGER;
TIMER time_between_applications;

START;
  
  TASK last_process_id := FIRST_PROCESS_ID;
  NEXTSTATE CreateApplicationProcess;

  STATE CreateApplicationProcess awake(0.0);
    INPUT NONE;
      DECISION last_process_id > NUM_OF_CONNECTIONS;
      (TRUE):
        STOP;
      (FALSE):
        CREATE LoadGenerator(last_process_id);
        TASK last_process_id := last_process_id + 1;
      ENDDECISION;
      NEXTSTATE -;
  ENDSTATE CreateApplicationProcess;
ENDPROCESS;

   SIGNALROUTE LowerSAP 
      FROM LoadGenerator TO ENV WITH (L1);
      FROM ENV TO LoadGenerator WITH (L2);

/*   SIGNALROUTE Load 
      FROM LoadGenerator TO Quelle WITH kill;
      FROM Quelle TO LoadGenerator WITH send_init; */
      
   CONNECT Application AND LowerSAP;
         
ENDBLOCK Application;

/****************************************************************************
 *
 * $RCSfile: Manager,v $
 * $Author: jruehl $
 * $Date: 1995/02/24 13:50:38 $
 * $Revision: 1.1 $
 ****************************************************************************/

PROCESS Manager (1,1);

/* Aufgabe des Prozesses ist die Impementation der Schnittstelle zwischen
   der Anwendung (ausserhalb des Systems) und TCP sowie der Schnittstelle
   zwischen TCP und IP. TCP_MODULE nimmt vom Environment TCP-Dienstprimitive
   entgegen und leitet sie an den durch den Parameter name festgelegten
   Portprozess weiter bzw. gibt von einem TCP_Port empfangene Indications
   ans Environment weiter. 
   Von IP ankommende Pakete leitet TCP_MODULE entsprechend des Parameters
   dp (Destination Port) an den entsprechenden Port weiter bzw. nimmt von den
   Ports Pakete entgegen und reicht sie an IP durch  */
   
   NEWTYPE PortAddress Array (PortRange,PId) ENDNEWTYPE;
   NEWTYPE ApplicationAddress Array (PortRange,PId) ENDNEWTYPE;
   NEWTYPE ExistPort Array (PortRange,Boolean) ENDNEWTYPE;
   
   SYNONYM ERROR_NO_FREE_PORT Integer = 0;
   SYNONYM UNDEFINED_DESTINATIONPORT Integer = -1;
   SYNONYM UNDEFINED_DESTINATIONADDRESS Integer = -1;
   
   DCL sp,dp,da,tout,toa,prec,sec,len,
       rcv_wnd,snd_wnd,name,descr,aaa,aar, run Integer;
   DCL urg,psh,ok Boolean;
   DCL n PortRange;	
   DCL exist ExistPort;
   DCL port_addr PortAddress;
   DCL appl_addr ApplicationAddress;
   DCL tcp_in Tcp;
   /* Liste der Variablen, die in den Signalen mitgesendet werden koennen */

   PROCEDURE CreatePort REFERENCED;
   PROCEDURE GetFreePort REFERENCED;	
   
   START;
       TASK run := 0;
       jump1:
       TASK exist(run) := FALSE;
       DECISION run = MAX_CONNECTIONS;
       (FALSE):
         TASK run := run + 1;
         JOIN jump1;
       (TRUE):
       ENDDECISION;
       NEXTSTATE WaitForInput;
       STATE WaitForInput;
           INPUT upo(sp,tout,toa,prec,sec);
               TASK n := 1;
               CALL GetFreePort(n);
               DECISION (n > MAX_CONNECTIONS);
               (TRUE):			/* alle Ports sind belegt !*/
                   OUTPUT of(ERROR_NO_FREE_PORT) VIA UpperSAP;
                   NEXTSTATE WaitForInput;
               (FALSE):
               ENDDECISION;
               CALL CreatePort(n,ok); 	/* erzeugt TCP_Port(n)-Prozess */   
               TASK appl_addr(n) := SENDER;
               OUTPUT upo(n,tout,toa,prec,sec) TO port_addr(n);
               OUTPUT oid(n,n,UNDEFINED_DESTINATIONPORT,
                          UNDEFINED_DESTINATIONADDRESS-1)  TO appl_addr(n); 	
               /* teilt der Anwendung den Namen fuer die neue Verbindung mit */
               NEXTSTATE WaitForInput;                            
           INPUT fspo(sp,dp,da,tout,toa,prec,sec);
               CALL CreatePort(sp,ok);
               DECISION ok;
               (FALSE):			/* Port schon belegt !!		*/
                  OUTPUT of(sp) VIA UpperSAP;
                  NEXTSTATE WaitForInput;
               (TRUE):
               ENDDECISION;
               OUTPUT fspo(sp,dp,da,tout,toa,prec,sec) TO port_addr(sp);
               TASK appl_addr(sp) := sender;
               OUTPUT  oid(sp,sp,dp,da)  TO appl_addr(sp);
                 	       /* Name der Verbindung gleich  Portnummer */
               NEXTSTATE WaitForInput;				   
           INPUT ao(sp,dp,da,tout,toa,prec,sec);
               CALL CreatePort(sp,ok);
               DECISION ok;
               (FALSE):			/* Port schon belegt !!		*/
                  OUTPUT of(sp) TO SENDER;
                  NEXTSTATE WaitForInput;
               (TRUE):
               ENDDECISION;
               OUTPUT ao(sp,dp,da,tout,toa,prec,sec) TO port_addr(sp);
               TASK appl_addr(sp) := sender;
               OUTPUT oid(sp,sp,dp,da) TO appl_addr(sp);
               NEXTSTATE WaitForInput;
           INPUT aod(sp,dp,da,tout,toa,prec,sec,len,psh,urg);
               CALL CreatePort(sp,ok);
               DECISION ok;
               (FALSE):			             /* Port schon belegt !!  */
                  OUTPUT of(sp) TO SENDER;
                  NEXTSTATE WaitForInput;
               (TRUE):
               ENDDECISION;
               OUTPUT aod(sp,dp,da,tout,toa,prec,sec,len,psh,urg) TO
                      port_addr(sp);
               TASK appl_addr(sp) := sender;
               OUTPUT oid(sp,sp,dp,da) TO appl_addr(sp);
               NEXTSTATE WaitForInput;
           INPUT send(name,len,psh,urg,tout,toa);
               DECISION exist(name);
               (TRUE):
                  OUTPUT send(name,len,psh,urg,tout,toa) TO port_addr(name);
               (FALSE):	                            /* Duplikate konsumieren  */
               ENDDECISION;
               NEXTSTATE WaitForInput;
           INPUT allocate(name,len);
               DECISION exist(name);
               (TRUE):               
                 OUTPUT allocate(name,len) TO port_addr(name);
               (FALSE):
               ENDDECISION;
               NEXTSTATE WaitForInput;
           INPUT del(name,len,urg);
               OUTPUT del(name,len,urg) TO appl_addr(name);
               NEXTSTATE WaitForInput;
           INPUT ter(name,descr);
               OUTPUT ter(name,descr) TO appl_addr(name);
               NEXTSTATE WaitForInput;
           INPUT err(name,descr);
                OUTPUT err(name,descr) TO appl_addr(name);
                NEXTSTATE -;
           INPUT stresp(name,dp,da,rcv_wnd,snd_wnd,aaa,aar,urg,
                        prec,sec,tout);
               OUTPUT stresp(name,dp,da,rcv_wnd,snd_wnd,aaa,aar,urg,
                               prec,sec,tout) TO appl_addr(name);
                NEXTSTATE WaitForInput;             
           INPUT closing(name);
               OUTPUT closing(name) TO appl_addr(name);
               NEXTSTATE WaitForInput;
           INPUT os (name);
               OUTPUT os (name) TO appl_addr(name);
               NEXTSTATE WaitForInput;
           INPUT of (name);
                 OUTPUT of (name) TO appl_addr(name);
               NEXTSTATE WaitForInput;
           INPUT abort (name);
               DECISION exist(name);
               (TRUE):
                 OUTPUT abort (name) TO port_addr(name);
               (FALSE):
               ENDDECISION;
               NEXTSTATE WaitForInput;
           INPUT close (name);
               DECISION exist(name);
               (TRUE):
                 OUTPUT close (name) TO port_addr(name);
               (FALSE):
               ENDDECISION;
               NEXTSTATE WaitForInput;
           INPUT status (name);
               DECISION exist(name);
               (TRUE):
                 OUTPUT status(name) TO port_addr(name);
               (FALSE):
               ENDDECISION;
               NEXTSTATE WaitForInput;
	       
	   INPUT tcp_packet(tcp_in);
	       DECISION sender = port_addr(tcp_in!sp);
	       (FALSE):
                 DECISION exist(tcp_in!dp);
                 (TRUE):
	             OUTPUT tcp_packet(tcp_in) TO port_addr(tcp_in!dp);
	         (FALSE):
	         ENDDECISION;
	       (TRUE):
	         OUTPUT tcp_packet(tcp_in) VIA LowerSAP;
	       ENDDECISION;
	       NEXTSTATE WaitForInput;
	   
	   INPUT process_terminated (name);
	       TASK exist(name):=FALSE;      /* Port n=name ist wieder frei ! */
	       NEXTSTATE WaitForInput;
	ENDSTATE WaitForInput;
ENDPROCESS Manager;

    
/*********** Prozess TCP_Port ***********************************************
 * $RCSfile: TCPPORT,v $
 * $Author: jruehl $
 * $Date: 1995/04/25 11:03:08 $
 * $Revision: 1.4 $
 ****************************************************************************/

PROCESS Port(0, MAX_CONNECTIONS);
/* Der Prozess wird vom TCP_Modul immer dann dynamisch erzeugt, wenn ein Active
   oder Passive Open von der Anwendungsschicht gefordert und der Port noch frei
    ist.Nach Abbruch der Verbindung beendet sich der Prozess (durch STOP)   */
   
DCL tcb TCBBlock;	        /* Kontrollblock	                      */
DCL tcp_in Tcp;          	/* TCP-Paketstructures	                      */
DCL rec_data TransmitData;	/* Speicherung vom Netz kommender Nutzdaten   */
DCL send_data TransmitData;	/* Speicherung vom Host kommender Daten	      */
DCL retransmit_queue ListOfRetrPackets;  /* Speicherung gesendeter Pakete     */
TIMER retr_timer(Integer),to_timer,rcv_timer,
      accept_timer, create_packet_timer;
DCL po,ok,psh,urg,close_connection,close_received,fin_tmp Boolean;
DCL n RetransmitRange;
DCL oldest,sp,tout,toa,prec,sec,len,da,dp,rbuffer Integer;
NEWTYPE TraceBlockProtocol Struct
  retransmitted, bad_checksum, bad_sequence, is_reset,
  packetoutput Integer;
ENDNEWTYPE;
DCL trace_block TraceBlockProtocol;
SYNONYM NO_DATA Integer = 0;
SYNONYM UNSPECIFIED_DP Integer = -1;
SYNONYM UNSPECIFIED_DA Integer = -1;
SYNONYM RESET_ERROR Integer = 0;

PROCEDURE SendRoutine REFERENCED;
PROCEDURE DataRequest REFERENCED;
PROCEDURE ResetRequest REFERENCED;
PROCEDURE SendStandard REFERENCED;
PROCEDURE AddRetransmit REFERENCED;
PROCEDURE GetFreeBuffer REFERENCED;
PROCEDURE SendRetransmit REFERENCED;
PROCEDURE UpdateRetransmit REFERENCED;
PROCEDURE UpdateTCB REFERENCED;
PROCEDURE AcceptPacket REFERENCED;
PROCEDURE CheckChecksum REFERENCED;
PROCEDURE CheckSynPacket REFERENCED;
PROCEDURE CheckSequence REFERENCED;
PROCEDURE IsReset REFERENCED;
PROCEDURE InitRetransmitQueue REFERENCED;
PROCEDURE Init REFERENCED;
PROCEDURE DeliverData REFERENCED;
PROCEDURE IsLastAck REFERENCED;

START;
   NEXTSTATE Closed;
     /* Passiver Wartezustand, ankommende Pakete werden abgelehnt, Warten auf
        Open Request von Anwendungsschicht                                   */
   STATE Closed;
      INPUT upo(sp,tout,toa,prec,sec);
         CALL Init(sp, UNSPECIFIED_DP,UNSPECIFIED_DA,tout,toa,prec,sec,
                    NO_PUSH_FLAG, NO_URGENT_FLAG);
         NEXTSTATE Listen;
      INPUT fspo(sp,dp,da,tout,toa,prec,sec);
         CALL Init (sp,dp,da,tout,toa,prec,sec,NO_PUSH_FLAG, NO_URGENT_FLAG);
         NEXTSTATE Listen;
      INPUT ao(sp,dp,da,tout,toa,prec,sec);
         CALL Init (sp,dp,da,tout,toa,prec,sec,NO_PUSH_FLAG, NO_URGENT_FLAG);
         CALL SendRoutine(NO_DATA,tcb!snd_nxt,NO_ACK_FLAG, SYN_FLAG,
                          NO_PUSH_FLAG,NO_URGENT_FLAG, NO_RESET_FLAG, 
                          NO_FIN_FLAG);
         NEXTSTATE SynSent;
      INPUT aod(sp,dp,da,tout,toa,prec,sec,len,psh,urg);
         CALL Init (sp,dp,da,tout,toa,prec,sec,psh,urg);
         CALL DataRequest(len, NO_ACK_FLAG, SYN_FLAG,
                           urg, psh, NO_RESET_FLAG, NO_FIN_FLAG);
         NEXTSTATE SynSent;
      INPUT tcp_packet (tcp_in);
         DECISION tcp_in!rst;
         (TRUE):	         /* Dann Paket ignorieren und Prozess beenden */
            OUTPUT process_terminated(tcb!sp) TO PARENT;
         (FALSE):	         /* Dann Reset schicken und Prozess beenden   */
            TASK len := NO_DATA;
            CALL ResetRequest(tcp_in!sa, tcp_in!sp, tcp_in!seq, ACK_FLAG, 
                              NO_SYN_FLAG, NO_URGENT_FLAG, NO_PUSH_FLAG,
                              RESET_FLAG, NO_FIN_FLAG);
            OUTPUT process_terminated(tcb!sp) TO PARENT;
         ENDDECISION;
         STOP;
   ENDSTATE Closed;
   
   STATE Listen;
     /* Nach Empfang eines Passive Open wartet der Port auf ankommende Syn-
        chronisationspakete von moeglichen Kommunikationspartern. Falls der
        Port ein Active Open Request erhaelt, sendet er selbst ein Synchro-
        nisationspaket                                                       */
        
      INPUT close(sp);
         OUTPUT process_terminated(tcb!sp) TO PARENT;
         STOP;
      INPUT ao(sp,dp,da,tout,toa,prec,sec);
         CALL Init(sp,dp,da,tout,toa,prec,sec,NO_PUSH_FLAG, NO_URGENT_FLAG);
         CALL SendRoutine(NO_DATA,tcb!snd_nxt,NO_ACK_FLAG,
                          SYN_FLAG, NO_URGENT_FLAG, NO_PUSH_FLAG,
                          NO_RESET_FLAG, NO_FIN_FLAG);
         NEXTSTATE SynSent;
      INPUT aod(sp,dp,da,tout,toa,prec,sec,len,psh,urg);
         CALL Init (sp,dp,da,tout,toa,prec,sec,psh,urg);
         CALL DataRequest(len, NO_ACK_FLAG,
                          SYN_FLAG, NO_URGENT_FLAG, NO_PUSH_FLAG,
                          NO_RESET_FLAG, NO_FIN_FLAG);
         TASK po:=TRUE;
         NEXTSTATE SynSent;
      INPUT tcp_packet(tcp_in);
         CALL CheckChecksum(tcp_in,ok);
         DECISION ok;
         (FALSE):	      /* physikalischer Uebertragungsfehler entdeckt  */
            NEXTSTATE Listen;
         (TRUE):	      /* dann weiterbearbeiten			      */
            CALL AcceptPacket(tcp_in);
            CALL SendRoutine(0,tcb!snd_nxt,ACK_FLAG,
                             SYN_FLAG, NO_URGENT_FLAG, NO_PUSH_FLAG,
                             NO_RESET_FLAG, NO_FIN_FLAG);
            NEXTSTATE SynReceived;
         ENDDECISION;
   ENDSTATE Listen;
   
   STATE SynReceived;
     /* Der Port hat im Zustand LISTEN ein Synchronisationspaket erhalten und
        mit einem eigenen Synchr.paket bestaetigt. Nun wartet er auf die Be-
        staetigung des Pakets (three way handshaking Verfahren!)             */
        
      INPUT close(sp);                 /* Close-Request der Anwendung        */
         CALL SendRoutine(NO_DATA,tcb!snd_nxt, ACK_FLAG,
                           NO_SYN_FLAG, NO_URGENT_FLAG, PUSH_FLAG,
                           NO_RESET_FLAG, FIN_FLAG);
         OUTPUT process_terminated(tcb!sp) TO PARENT;
         STOP;
         
      INPUT tcp_packet(tcp_in);
         CALL CheckChecksum(tcp_in,ok);
         DECISION ok;
         (FALSE):
            NEXTSTATE SynReceived;
         (TRUE):
         ENDDECISION;
         CALL IsReset(tcp_in,ok);
         DECISION ok;
         (TRUE):
            DECISION po;               /* Reset erhalten: falls Port Passive */
            (TRUE):                    /* Open erhielt: warte weiter, sonst  */ 
               NEXTSTATE Listen;       /* breche Verbindungsaufbau ab !      */
            (FALSE):
               OUTPUT ter(tcb!sp, RESET_ERROR) TO PARENT;
               OUTPUT process_terminated(tcb!sp) TO PARENT;
               STOP;
            ENDDECISION;
         (FALSE):
         ENDDECISION;
         CALL CheckSynPacket(tcp_in,ok); /* Ist Paket die Bestaetigung      */
         DECISION ok;                    /* unseres Synchron.pakets?        */
         (TRUE):		 /* ja, also ab in die Datentransferphase ! */
            CALL AcceptPacket(tcp_in);
            OUTPUT os(tcb!sp) TO PARENT;
            NEXTSTATE Established;
         (FALSE):		 /* z. B. Duplikat eines alten Pakets	    */
            NEXTSTATE SynReceived;
         ENDDECISION;
      INPUT retr_timer(n);       /* Retransmit-Timer hat gefeuert!!, also   */
         CALL SendRetransmit(n); /* erneute Sendung des Synchr.paketes      */
         NEXTSTATE SynReceived;

      INPUT rcv_timer;	        /* verhindert unendlich lange Wartezeiten   */
         SET (NOW + WAIT_DELAY, rcv_timer);
         NEXTSTATE SynReceived;

   ENDSTATE SynReceived;
   
   STATE SynSent;
     /* Port hat nach Erhalt eines Active Open Request ein Synchronisations-
        paket gesendet und wartet jetzt auf eine Antwort. Bei Ablehnung des
        Pakets (Reset-Flag gesetzt) Abbruch des Verbindungsaufbaus, bei
        Bestaetigung gehts ab in die Datentransferphase!                    */
        
      INPUT close(sp);                 /* Close-Request der Anwendung       */
         SET (NOW+MRTT,to_timer);
	 OUTPUT process_terminated(tcb!sp) TO PARENT;
         NEXTSTATE TimeWait;
      INPUT tcp_packet(tcp_in);
         CALL CheckChecksum(tcp_in,ok);
         DECISION ok;
         (FALSE):
            NEXTSTATE SynSent;
         (TRUE):
         ENDDECISION;
         DECISION ((tcp_in!rst) AND (tcp_in!seq=tcb!iss) );
         (TRUE):	                    /* Ablehnung unseres Syn-Paketes  */
            OUTPUT of(tcb!sp) TO PARENT;    /* Open Failure !	              */
            SET (NOW+MRTT,to_timer);
	    OUTPUT process_terminated(tcb!sp) TO PARENT;
            NEXTSTATE TimeWait;
         (FALSE):
         ENDDECISION;
         DECISION (tcp_in!syn AND NOT tcp_in!ack);
         (TRUE):	/* Ueberschneidung der beiden syn-Pakete */
            CALL AcceptPacket(tcp_in);
            CALL SendRoutine(NO_DATA,tcb!snd_nxt, ACK_FLAG, NO_SYN_FLAG,
                             NO_URGENT_FLAG, NO_PUSH_FLAG, NO_RESET_FLAG,
                             NO_FIN_FLAG);
           /* ACK senden und auf Bestaetigung des eigenen SYN-Paketes warten  */
            TASK po:=FALSE;
            NEXTSTATE SynReceived;
         (FALSE):
         ENDDECISION;
         DECISION ((tcp_in!syn) AND (tcp_in!ack) AND (tcp_in!an = tcb!snd_nxt));
         (TRUE):	/* Bestaetigung unseres syn-Paketes !	              */
            CALL AcceptPacket(tcp_in);
            CALL SendRoutine(NO_DATA,tcb!snd_nxt, ACK_FLAG, NO_SYN_FLAG,
                             NO_URGENT_FLAG, NO_PUSH_FLAG, NO_RESET_FLAG,
                             NO_FIN_FLAG);
            		/* dadurch geht auch Partner in State Established     */
            OUTPUT os(tcb!sp) TO PARENT;	/* Open Success               */
            NEXTSTATE Established;
         (FALSE):	/* Paket ablehnen und zerstoeren	              */
            TASK len := 0;
            CALL ResetRequest(tcp_in!sa,tcp_in!sp,tcp_in!seq,
                              ACK_FLAG, NO_SYN_FLAG,
                              NO_URGENT_FLAG, NO_PUSH_FLAG, RESET_FLAG,
                              NO_FIN_FLAG);
            NEXTSTATE SynSent;
         ENDDECISION;

      INPUT rcv_timer;	/* verhindert unendlich lange Wartezeiten	*/
         SET (NOW + WAIT_DELAY, rcv_timer);
         NEXTSTATE SynSent;

      INPUT retr_timer(n);
         CALL SendRetransmit(n);
         NEXTSTATE SynSent;
   ENDSTATE SynSent;
   
   STATE Established;
     /* In diesem Zustand koennen beide Seiten Daten senden und empfangen.
        Durch das send-Request uebergibt die Anwendung neue zu uebertragene
        Nutzdaten, die, falls die Fenstergroesse ausreicht, gesendet, und
        sonst zwischengespeichert werden. Ankommende Pakete werden auf
        Korrektheit geprueft (Pruefsumme, Sequenznummer, Bestaetigungsnummer).
        Bei einem close-Request der Anwendung wird der Verbindungsabbau ein-
        geleitet (wieder nach dem three way handshaking Prinzip              */
   
      INPUT send(sp,len,psh,urg,tout,toa);
         CALL DataRequest(len, ACK_FLAG, NO_SYN_FLAG,urg,psh,
                           NO_RESET_FLAG, NO_FIN_FLAG);
         /* vom Host empfangene Nutzdaten werden gesendet, wenn 
            a) das Push-Flag gesetzt ist oder
            b) ein Paket mit Standardlaenge gesendet werden kann und
            c) das Sendefenster ausreichend ist 			*/
         NEXTSTATE Established;   

      INPUT allocate(sp,len);          /* Anwendung stellt neuen Puffer fuer */
         TASK rbuffer := rbuffer+len;  /* ankommende Nutzdaten zur Verfuegung*/
         NEXTSTATE Established;
         
      INPUT close(sp);                 
         CALL DataRequest(NO_DATA, ACK_FLAG, NO_SYN_FLAG,
                          NO_URGENT_FLAG, PUSH_FLAG, NO_RESET_FLAG,
                          FIN_FLAG);
         /* Die Funktion sendet alle noch gespeicherten Daten
            und setzt im letzten Paket das fin-Flag, vorausgesetzt, das
            Sendefenster reicht aus					*/
         TASK send_data!fin := TRUE;
         DECISION send_data!len = 0;
         (TRUE):	/* Fenstergroesse war ausreichend		*/
            NEXTSTATE FinWait1;
         (FALSE):	/* also warten, bis Fenster wieder offen ist !	*/
            TASK close_connection := TRUE;
            NEXTSTATE Established;
         ENDDECISION;
         
      INPUT abort(sp);                 /* Wunsch nach sofortigem Verbindungs-*/
         OUTPUT process_terminated(tcb!sp) TO PARENT; /* abbau von Anwendung */
         STOP;
         
      INPUT status(sp);                /* Abfrage der im Transport Control   */
         OUTPUT stresp(tcb!sp,tcb!dp,  /* Block gespeicherten Werte der Verb.*/
                       tcb!da,tcb!rcv_wnd,tcb!snd_wnd,tcb!aaa,
                       tcb!aar,tcb!urg,tcb!prec,tcb!sec,tcb!tout) TO PARENT;
         NEXTSTATE Established; 
         
      INPUT retr_timer(n);
         CALL SendRetransmit(n);
         NEXTSTATE Established;
      
      INPUT tcp_packet(tcp_in);
         CALL CheckChecksum(tcp_in,ok); /* Pruefsumme korrekt?               */
         DECISION ok;
         (FALSE):
            NEXTSTATE Established;
         (TRUE):
         ENDDECISION;
         CALL IsReset(tcp_in,ok);      /* Reset-Flag gesetzt?                */
         DECISION ok;
         (TRUE):                       /* halboffene Verbindung schliessen ! */
            OUTPUT closing(tcb!sp) TO PARENT;
            OUTPUT process_terminated(tcb!sp) TO PARENT;
            SET (NOW+MRTT,to_timer);
            NEXTSTATE TimeWait;
         (FALSE):
         ENDDECISION;
         CALL CheckSequence(tcp_in,ok);          /* ist AN und Seq akzeptabel*/
         DECISION ok;
         (FALSE):	     /* nein, also Paket zerstoeren, es ist entweder */
	     TASK trace_block!bad_sequence := trace_block!bad_sequence + 1;             
         (TRUE):            /* ein Retransmit oder Paket einer alten Verb.   */
            CALL AcceptPacket(tcp_in);
            CALL DataRequest(NO_DATA, ACK_FLAG, NO_SYN_FLAG,
                             NO_URGENT_FLAG, NO_PUSH_FLAG, NO_RESET_FLAG,
                             close_connection);
        ENDDECISION;
        DECISION tcp_in!fin;           /* FIN-Flag gesetzt? dann will Partner*/
        (TRUE):                        /* keine Daten mehr senden!!          */
           OUTPUT closing(tcb!sp) TO PARENT;
           CALL DeliverData;
           CALL SendRoutine(NO_DATA,tcb!snd_nxt, ACK_FLAG, NO_SYN_FLAG,
                            NO_URGENT_FLAG, NO_PUSH_FLAG, NO_RESET_FLAG,
                            NO_FIN_FLAG);
           NEXTSTATE CloseWait;	/* Bestaetigung des FIN		*/
        (FALSE):
           DECISION close_connection AND send_data!len=0;
           (TRUE):	/* dann sind alle Daten und ein FIN gesendet !	*/
              NEXTSTATE FinWait1;
           (FALSE):
           ENDDECISION;
           NEXTSTATE Established;
        ENDDECISION;
         
      INPUT rcv_timer;	/* verhindert unendlich lange Wartezeiten	*/
         CALL SendRoutine(NO_DATA, tcb!snd_nxt, ACK_FLAG, NO_SYN_FLAG,
                          NO_URGENT_FLAG, NO_PUSH_FLAG, NO_RESET_FLAG,
                          NO_FIN_FLAG); 
         /* Senderoutine 1 sendet ein Datenpaket, um zu sehen, 
            ob der Partner noch existiert.				*/
         SET (NOW + WAIT_DELAY, rcv_timer);
         NEXTSTATE Established;
         
   ENDSTATE Established;   
   
         
   STATE FinWait1;  
     /* In diesem Zustand wartet der Port, bis auch der Partner durch Setzen
        des FIN-Flags anzeigt, dass er keine weiteren Daten mehr senden 
        moechte. So lange nimmt er noch Daten der anderen Seite entgege, gibt
        sie an die Anwendungsschicht weiter und sendet Bestaetigungspakete,  
        damit dass Sendefenster des Partners zwischendurch wieder geoffnet 
        wird.                                                                */

      INPUT send(sp,len,psh,urg,tout,toa);
        NEXTSTATE -;
        
      INPUT allocate(sp,len);
         TASK rbuffer := rbuffer+len;
         CALL DeliverData;
         NEXTSTATE FinWait1;
       
      INPUT tcp_packet(tcp_in);
         CALL CheckChecksum(tcp_in,ok);
         DECISION ok;
         (FALSE):
            NEXTSTATE FinWait1;
         (TRUE):
         ENDDECISION;
         CALL IsReset(tcp_in,ok);
         DECISION ok;
         (TRUE):	/* ist also korrektes Reset !	*/
            OUTPUT process_terminated(tcb!sp) TO PARENT;
	    SET (NOW+MRTT,to_timer);
	    NEXTSTATE TimeWait;
         (FALSE):
         ENDDECISION;
         CALL CheckSequence(tcp_in,ok);
         DECISION ok;
         (FALSE):	/* Reset schicken				*/
            CALL ResetRequest(tcp_in!sa,tcp_in!sp,tcp_in!seq, ACK_FLAG,
                              NO_SYN_FLAG, NO_URGENT_FLAG, NO_PUSH_FLAG,
                              RESET_FLAG, NO_FIN_FLAG); 
            NEXTSTATE FinWait1;
         (TRUE):
            CALL AcceptPacket(tcp_in);
            DECISION tcp_in!fin;
            (TRUE):
               CALL SendRoutine(0, tcb!snd_nxt, ACK_FLAG,
                                NO_SYN_FLAG, NO_URGENT_FLAG, NO_PUSH_FLAG,
                                NO_RESET_FLAG, FIN_FLAG); 
               OUTPUT closing(tcb!sp) TO PARENT;
               NEXTSTATE Closing;
            (FALSE):
            ENDDECISION;
            DECISION tcb!snd_nxt=tcp_in!an;
            (TRUE):
               NEXTSTATE FinWait2;
            (FALSE):
               NEXTSTATE FinWait1;
            ENDDECISION;
         ENDDECISION;
         
      INPUT retr_timer(n);
         CALL SendRetransmit(n);
         DECISION ok;
         (FALSE):                      /* Gegenseite ruehrt sich nicht mehr   */
		SET (NOW+MRTT,to_timer);
	        OUTPUT process_terminated(tcb!sp) TO PARENT;
		NEXTSTATE TimeWait;
         (TRUE):
         ENDDECISION;
         NEXTSTATE FinWait1;
         
      INPUT rcv_timer;	/* verhindert unendlich lange Wartezeiten	*/
         CALL SendRoutine(NO_DATA, tcb!snd_nxt, ACK_FLAG, NO_SYN_FLAG,
                          NO_URGENT_FLAG, NO_PUSH_FLAG, NO_RESET_FLAG,
                          NO_FIN_FLAG); 
         /* Senderoutine 1 sendet ein Datenpaket, um zu sehen, 
            ob der Partner noch existiert.				*/
         SET (NOW + WAIT_DELAY, rcv_timer);
         NEXTSTATE -;

  ENDSTATE FinWait1;	
            
         
STATE FinWait2;      
  /* In diesem Zustand wartet der Port wie in FinWait1 auf das Zeichen des
     Partners, die Verbindung abzubauen. Allerdings sind bereits alle eigenen
     gesendeten Daten bestaetigt worden.                                     */

      INPUT send(sp,len,psh,urg,tout,toa);
        NEXTSTATE -;

   INPUT allocate(sp,len);
	TASK rbuffer := rbuffer+len;
	CALL DeliverData;
	DECISION (rec_data!len=0 AND close_received);
	(TRUE):	/* FIN von Remote TCP erhalten und alle Daten ausgeliefert */
		SET (NOW+MRTT,to_timer);
	        OUTPUT process_terminated(tcb!sp) TO PARENT;
		NEXTSTATE TimeWait;
	(FALSE):
	   NEXTSTATE FinWait2;
	ENDDECISION;

   INPUT tcp_packet(tcp_in);
	CALL CheckChecksum(tcp_in,ok);
	DECISION ok;
	(FALSE):
		NEXTSTATE FinWait2;
	(TRUE):
	   CALL IsReset(tcp_in,ok);
	   DECISION ok;
	   (TRUE):
               OUTPUT process_terminated(tcb!sp) TO PARENT;
	       SET (NOW+MRTT,to_timer);
	       NEXTSTATE TimeWait; 
           (FALSE):
	      CALL CheckSequence(tcp_in,ok);
	      DECISION ok;
	      (FALSE):
	          NEXTSTATE FinWait2;
	      (TRUE):
		   CALL AcceptPacket(tcp_in);
		   CALL SendRoutine(NO_DATA, tcb!snd_nxt, ACK_FLAG,
                                  NO_SYN_FLAG, NO_URGENT_FLAG, NO_PUSH_FLAG,
                                  NO_RESET_FLAG, FIN_FLAG); 
		   DECISION tcp_in!fin;  /* Parner ist auch fertig!!           */
		   (FALSE):
			NEXTSTATE FinWait2;
		   (TRUE):
			DECISION rec_data!len>0;   /* konnten schon alle empfan*/
			(TRUE):          /* genen Nutzdaten uebergeben werden ?*/
				TASK close_received := TRUE;
					/* FIN erhalten, aber noch nicht alle
					   Daten konnten ausgeliefert werden  */
				NEXTSTATE FinWait2;
			(FALSE):
	                        OUTPUT process_terminated(tcb!sp) TO PARENT;
				SET (NOW + MRTT,to_timer);
				NEXTSTATE TimeWait;
			ENDDECISION;
		   ENDDECISION;
	      ENDDECISION;
	   ENDDECISION;
	ENDDECISION;

   INPUT retr_timer(n);
	CALL SendRetransmit(n);
         DECISION ok;
         (FALSE):                      /* Gegenseite ruehrt sich nicht mehr   */
		SET (NOW+MRTT,to_timer);
           	OUTPUT process_terminated(tcb!sp) TO PARENT;
		NEXTSTATE TimeWait;
         (TRUE):
         ENDDECISION;
	NEXTSTATE FinWait2;

      INPUT rcv_timer;	/* verhindert unendlich lange Wartezeiten	*/
         CALL SendRoutine(NO_DATA, tcb!snd_nxt, ACK_FLAG, NO_SYN_FLAG,
                          NO_URGENT_FLAG, NO_PUSH_FLAG, NO_RESET_FLAG,
                          NO_FIN_FLAG); 
         /* Senderoutine 1 sendet ein Datenpaket, um zu sehen, 
            ob der Partner noch existiert.				*/
         SET (NOW + WAIT_DELAY, rcv_timer);
         NEXTSTATE -;

ENDSTATE FinWait2;

STATE Closing;
  /* In diesem Zustand wartet der Port, bis der Partner das letzte Datenpaket
     bestaetigt hat. Dann ist Verbindung erfolgreich abgeschlossen.          */

   INPUT allocate(sp,len);
	TASK rbuffer := rbuffer+len;
	CALL DeliverData;
	DECISION (rec_data!len = NO_DATA AND close_received);
	(TRUE):	/* ACK von Remote TCP erhalten und alle Daten ausgeliefert */
		SET (NOW + MRTT,to_timer);
	        OUTPUT process_terminated(tcb!sp) TO PARENT;
		NEXTSTATE TimeWait;
	(FALSE):
	   NEXTSTATE FinWait2;
	ENDDECISION;

   INPUT tcp_packet(tcp_in);
	CALL CheckChecksum(tcp_in,ok);
	DECISION ok;
	(TRUE):
	(FALSE):
		NEXTSTATE Closing;
	ENDDECISION;
	CALL IsReset(tcp_in,ok);
	DECISION ok;
	(TRUE):
            OUTPUT process_terminated(tcb!sp) TO PARENT;
	    SET (NOW + MRTT,to_timer);
	    NEXTSTATE TimeWait;
        (FALSE):
        ENDDECISION;
        CALL CheckSequence(tcp_in,ok);
        DECISION ok;
        (FALSE):
           NEXTSTATE Closing;
        (TRUE):
           CALL AcceptPacket(tcp_in);
        ENDDECISION;
        DECISION tcp_in!an = tcb!snd_nxt;  /* alle Daten gut angekommen!!    */
        (TRUE):
           DECISION rec_data!len = 0;
           (TRUE):
              SET (NOW + TIME_OUT,to_timer);
	      OUTPUT process_terminated(tcb!sp) TO PARENT;
              NEXTSTATE TimeWait;
           (FALSE):
              TASK close_received := TRUE;
           ENDDECISION;
        (FALSE):	/* weiter auf Bestaetigung des FIN warten	*/
        ENDDECISION; 
        NEXTSTATE Closing;
        
   INPUT retr_timer(n);
	CALL SendRetransmit(n);
         DECISION ok;
         (FALSE):                      /* Gegenseite ruehrt sich nicht mehr   */
		SET (NOW + MRTT,to_timer);
	        OUTPUT process_terminated(tcb!sp) TO PARENT;
		NEXTSTATE TimeWait;
         (TRUE):
         ENDDECISION;
	NEXTSTATE Closing;

      INPUT rcv_timer;	/* verhindert unendlich lange Wartezeiten	*/
         CALL SendRoutine(NO_DATA, tcb!snd_nxt, ACK_FLAG, NO_SYN_FLAG,
                          NO_URGENT_FLAG, NO_PUSH_FLAG, NO_RESET_FLAG,
                          NO_FIN_FLAG); 
         /* Senderoutine 1 sendet ein Datenpaket, um zu sehen, 
            ob der Partner noch existiert.				*/
         SET (NOW + WAIT_DELAY, rcv_timer);
         NEXTSTATE -;

ENDSTATE Closing;

STATE CloseWait;
  /* In diesem Zustand wartet der Port, bis die Anwendungsschicht durch ein
     Close-Request anzeigt, dass sie ebenfalls die Verbindung abbauen moechte*/

   INPUT tcp_packet(tcp_in);           /* kann eigentlich nur ein Bestaeti-  */
	CALL CheckChecksum(tcp_in,ok);  /* gungspaket sein                    */
	DECISION ok;
	(FALSE):
	  NEXTSTATE CloseWait;
	(TRUE):
	ENDDECISION;
	CALL IsReset(tcp_in,ok);
	DECISION ok;
	(TRUE):
            OUTPUT process_terminated(tcb!sp) TO PARENT;
	    SET (NOW + MRTT,to_timer);
	    NEXTSTATE TimeWait;
        (FALSE):
        ENDDECISION;	   
	CALL CheckSequence(tcp_in,ok);
	DECISION ok;
	(FALSE):
	  NEXTSTATE CloseWait;
	(TRUE):
		CALL AcceptPacket(tcp_in);
		CALL DataRequest(NO_DATA, ACK_FLAG,
                               NO_SYN_FLAG, NO_URGENT_FLAG, NO_PUSH_FLAG,
                               NO_RESET_FLAG, NO_FIN_FLAG);
			/* Sendefenster wieder weiter geoeffnet !!	*/
		DECISION (send_data!len = 0 AND close_connection);
		(TRUE):	/* alle gepufferten Daten + FIN sind gesendet	*/
			NEXTSTATE LastAck;
		(FALSE):
		ENDDECISION;
		NEXTSTATE CloseWait;
	ENDDECISION;

   INPUT to_timer;
	CALL SendRoutine(NO_DATA, tcb!snd_nxt, ACK_FLAG,
                          NO_SYN_FLAG, NO_URGENT_FLAG, NO_PUSH_FLAG,
                          NO_RESET_FLAG, NO_FIN_FLAG);
						/* leeres Paket	*/
	SET (NOW + TIME_OUT,to_timer);
	NEXTSTATE CloseWait;

   INPUT retr_timer(n);
	CALL SendRetransmit(n);
         DECISION ok;
         (FALSE):                      /* Gegenseite ruehrt sich nicht mehr   */
		SET (NOW + MRTT,to_timer);
	        OUTPUT process_terminated(tcb!sp) TO PARENT;
		NEXTSTATE TimeWait;
         (TRUE):
         ENDDECISION;
	NEXTSTATE CloseWait;

   INPUT allocate(sp,len);
	TASK rbuffer := rbuffer+len;
	CALL DeliverData;
	NEXTSTATE CloseWait;

   INPUT close(sp);
	CALL DataRequest(NO_DATA, ACK_FLAG,
                        NO_SYN_FLAG, NO_URGENT_FLAG, PUSH_FLAG,
                        NO_RESET_FLAG, FIN_FLAG);
	DECISION send_data!len = 0;
	(TRUE):	/* Warten auf Bestaetigung des FIN-Paketes	*/
		NEXTSTATE LastAck;
	(FALSE):       /* es sind noch ungesendete Sendedaten gepuffert       */
		TASK close_connection:=TRUE;
		NEXTSTATE CloseWait;
	ENDDECISION;

   INPUT send(sp,len,psh,urg,tout,toa);
	CALL DataRequest(len, ACK_FLAG,NO_SYN_FLAG, urg, psh,
                        NO_RESET_FLAG, NO_FIN_FLAG);
	NEXTSTATE CloseWait;
	
   INPUT rcv_timer;	/* verhindert unendlich lange Wartezeiten	*/
         CALL SendRoutine(NO_DATA, tcb!snd_nxt, ACK_FLAG,
                           NO_SYN_FLAG, NO_URGENT_FLAG, NO_PUSH_FLAG,
                           NO_RESET_FLAG, NO_FIN_FLAG);
         /* Senderoutine 1 sendet ein Datenpaket, um zu sehen, 
            ob der Partner noch existiert.				*/
         NEXTSTATE CloseWait;
         	
ENDSTATE CloseWait;

STATE LastAck;
  /* Letzter Zustand des three way handshaking Mechanismus beim Verbindungs-
     abbau. Warten auf Bestaetigung des FIN und letzten Datenpakets          */

   INPUT allocate(sp,len);
	TASK rbuffer := rbuffer+len;
	CALL DeliverData;
	DECISION (rec_data!len=0 AND close_connection);
	(TRUE):	/* ACK von Remote TCP erhalten und alle Daten ausgeliefert */
		SET (NOW + MRTT,to_timer);
	        OUTPUT process_terminated(tcb!sp) TO PARENT;
		NEXTSTATE TimeWait;
	(FALSE):
	   NEXTSTATE LastAck;
	ENDDECISION;

   INPUT tcp_packet(tcp_in);
	CALL CheckChecksum(tcp_in,ok);
	DECISION ok;
	(FALSE):
	    NEXTSTATE LastAck;
	(TRUE):
	ENDDECISION;
	CALL IsReset(tcp_in,ok);
	DECISION ok;
	(TRUE):
            SET (NOW + MRTT,to_timer);
	    OUTPUT process_terminated(tcb!sp) TO PARENT;
	    NEXTSTATE TimeWait;
        (FALSE):
        ENDDECISION;	   
	CALL CheckSequence(tcp_in,ok);
	DECISION ok;
	(FALSE):
	    NEXTSTATE LastAck;
	(TRUE):
	    CALL AcceptPacket(tcp_in);
	ENDDECISION;
	CALL IsLastAck(tcp_in,ok);      /* Ack des letzten Datenpaketes?      */
	DECISION ok;
	(TRUE):
	   DECISION rec_data!len = 0;
	   (TRUE): 	/* Verbindung erfolgreich abgebaut !	*/
		SET (NOW+MRTT,to_timer);
	        OUTPUT process_terminated(tcb!sp) TO PARENT;
		NEXTSTATE TimeWait;
	   (FALSE):
	        TASK close_connection := TRUE;
	        NEXTSTATE LastAck;
	   ENDDECISION;
	(FALSE):
	    NEXTSTATE LastAck;
	ENDDECISION;

   INPUT retr_timer(n);
	CALL SendRetransmit(n);
         DECISION ok;
         (FALSE):                      /* Gegenseite ruehrt sich nicht mehr   */
		SET (NOW + MRTT,to_timer);
	        OUTPUT process_terminated(tcb!sp) TO PARENT;
		NEXTSTATE TimeWait;
         (TRUE):
         ENDDECISION;
	NEXTSTATE LastAck;

      INPUT rcv_timer;	/* verhindert unendlich lange Wartezeiten	*/
         CALL SendRoutine(NO_DATA, tcb!snd_nxt, ACK_FLAG, NO_SYN_FLAG,
                           NO_URGENT_FLAG, NO_PUSH_FLAG, NO_RESET_FLAG,
                           NO_FIN_FLAG); 
         /* Senderoutine 1 sendet ein Datenpaket, um zu sehen, 
            ob der Partner noch existiert.				*/
         SET (NOW + WAIT_DELAY, rcv_timer);
         NEXTSTATE -;

ENDSTATE LastAck;

STATE TimeWait;
  /* Dieser Zustand dient dazu, nach Verbindungsabbau nicht sofort wieder in
     den Zustand Closed zu gehen und eine neue Verbindung aufbauen zu koennen,
     sondern erst kurze Zeit auszusetzen, bis ggf. noch kreisende Pakete der
     letzten Verbindung ausgeliefert bzw. zerstoert wurden, so dass sie nicht
     zufaellig mit Paketen der neuen Verbindung vermischt werden koennen.   */

   INPUT to_timer;
        OUTPUT ter(tcb!sp,0) TO PARENT;
	STOP;
   
   INPUT *;
     NEXTSTATE -;
ENDSTATE TimeWait;

ENDPROCESS Port;

/****************************************************************************
 *
 * $RCSfile: IP_ACTIVITY,v $
 * $Author: jruehl $
 * $Date: 1995/02/24 13:51:30 $
 * $Revision: 1.1 $
 ****************************************************************************/

PROCESS Activity (1,1);	
/* Die Funktionalitaet von IP, allerdings ohne Fragmentierung */

DCL tcp_in Tcp;
DCL ip_in Ip;

PROCEDURE Deliver REFERENCED;
PROCEDURE SendPacket REFERENCED;

START;
    NEXTSTATE WaitForInput;
    STATE WaitForInput;
        INPUT tcp_packet(tcp_in);
           CALL SendPacket(tcp_in);	/* erzeuge Datagramm und gebe es an */
      	   NEXTSTATE WaitForInput;	/* die Mediumschicht weiter    	*/
      	
        INPUT ip_packet(ip_in);
           CALL Deliver(ip_in);	/* prueft Checksum und uebergibt Datagramm */
           NEXTSTATE WaitForInput;	/* an das TCP-Modul weiter	*/
    ENDSTATE WaitForInput;
    
ENDPROCESS Activity;
    

/****************************************************************************
 *
 * $RCSfile: MediumProcess,v $
 * $Author: jruehl $
 * $Date: 1995/04/25 11:04:18 $
 * $Revision: 1.2 $
 ****************************************************************************/

/*$ hier koennen spaeter Uebertragungsfehler eingebaut werden $*/

PROCESS Transport (1,1);
DCL ip_in Ip;                                  
DCL packet_nr Integer;
DCL packets Integer;
TIMER delay_finished(Integer);

START;
   TASK packets := 0;
   NEXTSTATE Ready;
   STATE Ready;
   
      INPUT ip_packet(ip_in);                  /* ankommende Pakete werden   */
        DECISION ip_in!dst;                    /* verzoegert                 */
          (SERVER_A_ADDRESS):
            /* REQUEST deliver(ip_in!len) VIA serv1;  Kanalgeschwindigkeit   */
            OUTPUT ip_packet(ip_in) VIA UpperSAP;
          (SERVER_B_ADDRESS):
         /* in Routingtabelle nachsehen und Paket weiterleiten   */
        ENDDECISION;
        NEXTSTATE Ready;                      
         
   ENDSTATE Ready;
   
ENDPROCESS Transport;
    
                     
/*****************************************************************************
 *           $RCSfile: PROCEDURES,v $
 * $Author: jruehl $
 * $Date: 1995/04/25 11:03:38 $
 * $Revision: 1.4 $
 ****************************************************************************/

/**** Prozeduren von TCP_MODULE *********************************************/

PROCEDURE CreatePort;
    FPAR n PortRange,
         IN/OUT ok Boolean;
    START;
    DECISION exist(n);
    (FALSE):
       CREATE Port;
       TASK port_addr(n) := OFFSPRING,
            ok := TRUE,
            exist(n) := TRUE;
       RETURN;
    (TRUE):
       TASK ok := FALSE;
       RETURN;
    ENDDECISION;
ENDPROCEDURE CreatePort;

PROCEDURE GetFreePort;
FPAR IN/OUT n PortRange; 
START;
     jump1:
     DECISION exist(n) = TRUE;
     (FALSE): 	/* Dann ist Port n nicht belegt !	*/
     (TRUE): 
        TASK n := n+1;
        JOIN jump1;
     ENDDECISION;
     RETURN;
ENDPROCEDURE GetFreePort;               

/*$***********************Prozeduren von TCP_PORT-Prozessen**********$*/

PROCEDURE SendRoutine;
FPAR len, seq Integer,
     ack,syn,urg,psh,rst,fin Boolean;
/* Die Prozedur sendet ein Datagramm mit den uebergebenen Werten	*/
DCL tcp_out Tcp;

   START;
       /* REQUEST compute_packet(len) VIA serv2;Erzeugen des Paketes,        */
       DECISION tcb!snd_wnd < len;
       (TRUE):
	 RETURN;
       (FALSE):
       ENDDECISION;
       TASK tcp_out!sp := tcb!sp,
         tcp_out!dp := tcb!dp,
         tcp_out!da := tcb!da,
         tcp_out!len := len,
         tcp_out!cs := len,
   	 tcp_out!urg := urg,
   	 tcp_out!ack := ack,
   	 tcp_out!syn := syn,
   	 tcp_out!psh := psh,
   	 tcp_out!rst := rst,
   	 tcp_out!fin := fin,
   	 tcp_out!an := tcb!rcv_nxt,
   	 tcp_out!seq := seq,
   	 tcp_out!wnd := window_size,
   	 tcp_out!sa := 0,
   	 tcp_out!urgp := 0;
       DECISION urg;
       (TRUE):
	 TASK tcp_out!urgp := len;
       (FALSE):
       ENDDECISION;
       TASK tcb!snd_wnd := tcb!snd_wnd - len;
       TASK tcb!snd_nxt := (tcb!snd_nxt + len) mod MAXNR;
       CALL AddRetransmit(tcp_out);
       OUTPUT tcp_packet(tcp_out) TO PARENT;
       CALL DeliverData;
       TASK trace_block!packetoutput := trace_block!packetoutput + 1;
       SET (NOW+WAIT_DELAY,rcv_timer);  /* Timer, der bei langen Sendepausen  */
       RETURN;                          /* ablaeuft, um Deadlocks zu vermeiden*/
ENDPROCEDURE SendRoutine;

PROCEDURE DataRequest;
FPAR len Integer,
     ack,syn,urg,psh,rst,fin Boolean;
/* Die Prozedur uebernimmt ggf. neue Sendedaten, prueft, ob das Push-Flag 
   gesetzt ist und das Sendefenster ausreicht, um die dringenden Daten zu 
   senden. Fall kein Push-Flag gesetzt ist, prueft die Routine, 
   ob ein Standardpaket gesendet werden kann.	*/
START;
   jump1:
   DECISION fin;	/* erst im letzten Datenpaket wird das FIN-FLAG	*/
   (TRUE):		/* gesetzt !					*/
      DECISION send_data!len <= STANDARD AND tcb!snd_wnd >= send_data!len;
      (TRUE):
      (FALSE):
         TASK fin := FALSE,
              fin_tmp := TRUE;
      ENDDECISION;
   (FALSE):
   ENDDECISION;
   TASK send_data!len := send_data!len + len;
   DECISION urg;
   (TRUE):
	TASK send_data!urg := TRUE,
	     send_data!urgp := send_data!len;
   (FALSE):
   ENDDECISION;
   DECISION psh;
   (TRUE):
	TASK send_data!psh := TRUE,
	     send_data!pshp := send_data!len;
   (FALSE):
   ENDDECISION;
   DECISION send_data!psh;
   (TRUE):
     DECISION tcb!snd_wnd >= send_data!pshp OR tcb!snd_wnd >= STANDARD;
     (TRUE):
	DECISION send_data!len > STANDARD AND tcb!snd_wnd >= STANDARD;
	(TRUE):	/* dann Paket mit Standardlaenge senden */
		DECISION send_data!urgp > STANDARD;
		(TRUE):
			TASK send_data!urgp := send_data!urgp-STANDARD;
			CALL SendRoutine(STANDARD, tcb!snd_nxt,
			                  ack,syn,send_data!urg,
					  send_data!psh,rst,fin);
		(FALSE):
			CALL SendRoutine(STANDARD,tcb!snd_nxt,ack,
			                  syn,send_data!urg,
					  send_data!psh,rst,fin);
			TASK send_data!urgp := 0,
			     send_data!urg := FALSE;
		ENDDECISION;
		TASK send_data!len := send_data!len - STANDARD;
		DECISION send_data!pshp>STANDARD;
		(TRUE):
			TASK send_data!pshp := send_data!pshp-STANDARD;
		(FALSE):
			TASK send_data!pshp := 0,
			     send_data!psh := FALSE;
		ENDDECISION;
		TASK len := 0,
		     urg := send_data!urg,
		     psh := send_data!psh,
		     fin := fin_tmp; 
		JOIN jump1;
			/* falls moeglich, weiteres Datenpaket absenden */
	(FALSE):	/* Dann Paket mit allen gepufferten Daten senden */
		DECISION send_data!pshp<=tcb!snd_wnd;		
		(TRUE):	/* Sendefenster ausreichend fuer Push-Daten	*/
		   CALL SendRoutine(send_data!pshp,tcb!snd_nxt,
		                     ack,syn,send_data!urg,
		   	             send_data!psh,rst,fin);
		   TASK send_data!len := send_data!len - send_data!pshp,
		        send_data!pshp := 0,
		        send_data!psh := FALSE;
		   TASK send_data!urg := FALSE,
		        send_data!urgp := 0;
		(FALSE):
		ENDDECISION;
		RETURN;
	ENDDECISION;
     (FALSE): /* Push-Daten koennen wegen eines zu kleinen Sendefensters
		nicht gesendet werden */
		CALL SendStandard;
		RETURN;
     ENDDECISION;
   (FALSE): /* kein Push-Flag war gesetzt ! */
       CALL SendStandard;
       RETURN;
   ENDDECISION;
ENDPROCEDURE DataRequest;

PROCEDURE ResetRequest;
FPAR da,dp,len Integer,
     ack,syn,urg,psh,rst,fin Boolean;
/* Die Prozedur sendet ein Reset 	*/
DCL tcp_out Tcp;
   START;
   TASK tcp_out!sp := tcb!sp,
        tcp_out!dp := dp,
        tcp_out!da := da,
        tcp_out!len := 0,                /* eigentlich erhaelt das Laengenfeld */
        tcp_out!cs := 0,                 /* die Sequenznummer des abgelehnten  */
   	tcp_out!urg := urg,              /* Paketes                            */
   	tcp_out!ack := ack,
   	tcp_out!syn := syn,
   	tcp_out!psh := psh,
   	tcp_out!rst := rst,
   	tcp_out!fin := fin,
   	tcp_out!an := tcb!rcv_nxt,
   	tcp_out!seq := tcb!snd_nxt,
   	tcp_out!wnd := tcb!rcv_wnd,
   	len := 0;
   OUTPUT tcp_packet(tcp_out) TO PARENT;
   RETURN;
ENDPROCEDURE ResetRequest;

PROCEDURE SendStandard;
DCL urg Boolean;
START;
   DECISION send_data!len >= STANDARD AND tcb!snd_wnd >= STANDARD;
   (FALSE):
	RETURN;
   (TRUE):
	DECISION send_data!urg;
	(TRUE):
		TASK urg := TRUE;
		DECISION send_data!urgp > STANDARD;
		(TRUE):
			TASK send_data!urgp := send_data!urgp-STANDARD;
		(FALSE):
			TASK send_data!urgp := 0,
			     send_data!urg := FALSE;
		ENDDECISION;
	(FALSE):
	ENDDECISION;
	CALL SendRoutine(STANDARD,tcb!snd_nxt,TRUE,FALSE,urg,
	                  FALSE,FALSE,FALSE);
	TASK send_data!len := send_data!len-STANDARD;
	CALL SendStandard;
   ENDDECISION;
   RETURN;
ENDPROCEDURE SendStandard;

PROCEDURE AddRetransmit;
FPAR tcp_out Tcp;
DCL new RetransmitPacket;
START;
   TASK n := oldest;                     /* sucht ab aeltestem unbestaetigtem*/
   CALL GetFreeBuffer(n);              /* Paket nach naechstem freien Platz  */
   TASK new!tcp_packet!sp := tcp_out!sp,   /* im Retransmit-Puffer           */   
	new!tcp_packet!dp := tcp_out!dp,
	new!tcp_packet!da := tcp_out!da,
	new!tcp_packet!len := tcp_out!len,
	new!tcp_packet!cs := tcp_out!cs,
	new!tcp_packet!syn := tcp_out!syn,
	new!tcp_packet!ack := tcp_out!ack,
	new!tcp_packet!psh := tcp_out!urg,
	new!tcp_packet!urgp := tcp_out!urgp,
	new!tcp_packet!fin := tcp_out!fin,
	new!tcp_packet!rst := tcp_out!rst,
	new!tcp_packet!wnd := tcp_out!wnd,
	new!tcp_packet!an := tcp_out!an,
	new!tcp_packet!seq := tcp_out!seq,
	new!Failed_Retransmit := 0,
	new!Activ := TRUE,
   	retransmit_queue(n) := new;
   SET (NOW + Default_TO,retr_timer(n));
   RETURN;
ENDPROCEDURE AddRetransmit;

PROCEDURE GetFreeBuffer;
FPAR IN/OUT n RetransmitRange;
DCL new RetransmitPacket;
START;
   jump1:
   TASK new := retransmit_queue(n);
   DECISION new!Activ;
   (TRUE):	/* dann ist dieses Feld mit unbestaetigten Daten gefuellt     */
	TASK n := (n + 1) mod BUFFER_SIZE;
	JOIN jump1;
   (FALSE):
	RETURN;
   ENDDECISION;
ENDPROCEDURE GetFreeBuffer;

PROCEDURE SendRetransmit;                      /* sendet jetzt alle nach dem */
FPAR n RetransmitRange;                        /* abgelaufenen Paket noch    */
DCL new RetransmitPacket;                      /* gesendeten unbestaetigeten */
START;                                         /* Pakete, Variante 2         */                                     
   jump1:
   TASK new := retransmit_queue(n);
   DECISION new!activ;
   (TRUE):
   	TASK new!Failed_Retransmit := new!Failed_Retransmit + 1;
   (FALSE):
	TASK ok := TRUE;               
        RETURN;
   ENDDECISION;
   DECISION new!Failed_Retransmit > max_retransmit;
   (TRUE):	/* Dann Verbindungsabbruch	*/
	OUTPUT closing(tcb!sp);
	TASK ok := FALSE;
	RETURN;
   (FALSE):	                      /* Dann Paket noch einmal senden        */
          /* request compute_packet(new!tcp_packet!len) VIA serv2; 
	  OUTPUT tcp_packet(new!tcp_packet) TO PARENT; */
	  TASK trace_block!retransmitted := trace_block!retransmitted + 1,
	       new!Failed_Retransmit := new!Failed_Retransmit + 1,
	       retransmit_queue(n) := new;
	  OUTPUT err(tcb!sp, DEFAULT_ERROR) TO PARENT; 
	  SET (NOW + Default_TO, retr_timer(n)); 
	  DECISION n = BUFFER_SIZE;
	  (TRUE):
	      TASK n := 0;
	  (FALSE):
	      TASK n := n + 1;
	  ENDDECISION;
	  join jump1;                   /* bis alle unbest. Pakete gesendet    */   
   ENDDECISION;
   RETURN;
ENDPROCEDURE SendRetransmit;

PROCEDURE UpdateRetransmit;
FPAR tcp_in Tcp;
DCL old RetransmitPacket;
START;
   jump1:
   TASK old := retransmit_queue(oldest);
   DECISION old!activ;
   (FALSE):		 /* Es stehen keine unbestaetigten Daten aus !	*/
         TASK oldest := 0; /* Das naechste gesendete Paket wird am	*/
         RETURN;	 /* Pufferanfang abgelegt !			*/
   (TRUE):
   ENDDECISION;
   DECISION (old!tcp_packet!seq + old!tcp_packet!len <= tcp_in!an) OR
   	    (old!tcp_packet!seq + old!tcp_packet!len > tcp_in!an AND
   	     old!tcp_packet!seq > tcp_in!an) ;
   (TRUE):	/* Dann entfernen, da die Daten bestaetigt wurden       */
	RESET (retr_timer(oldest));  /* Timer zuruecksetzen und         */ 
	TASK old!activ := FALSE,       /* Flag umsetzen                   */
	     retransmit_queue(oldest) := old,
	     oldest :=  (oldest + 1) mod BUFFER_SIZE;   
	                             /* ist noch ein Paket bestaetigt ? */
	JOIN jump1;                  /*    dann selbe Prozedur nochmal  */
   (FALSE):	/* Dann Kontrollblock aktualisieren und abbrechen	*/
   ENDDECISION;
   RETURN;
ENDPROCEDURE UpdateRetransmit;

PROCEDURE UpdateTCB;
FPAR tcp_in Tcp;
DCL dispose, tmp Integer;         /* Anzahl bestaetigter Bytes u. Hilfsv.    */
START;
   DECISION tcb!snd_nxt >= tcp_in!an;  
   (TRUE):
	TASK dispose := tcb!snd_nxt - tcp_in!an;
   (FALSE):
	TASK dispose := (maxnr - tcp_in!an + tcb!snd_nxt);
   ENDDECISION;
   TASK tcb!snd_una := tcp_in!an,  /* Aeltestes unbestaetigtes Byte            */
        tmp := tcp_in!seq + tcp_in!len,         /* naechste Empfangssequenznr. */
                                              /* modulo maxnr !!!!!!!        */
	tcb!snd_wnd := tcp_in!wnd - dispose,      /* Credits erhoehen            */
	tcb!rcv_wnd := tcb!rcv_wnd - tcp_in!len;  /* Empfangsfenster verkleinern */
   TASK tcb!rcv_nxt := (tcp_in!seq + tcp_in!len) mod MAXNR;
   RETURN;
ENDPROCEDURE UpdateTCB;

PROCEDURE AcceptPacket;
FPAR tcp_in Tcp;
START;
      /* request compute_packet(len) VIA serv2;Erzeugen des Paketes,        */
      DECISION tcb!dp = -1;              
      (TRUE):			       /* Passive Open !                     */
        TASK tcb!dp := tcp_in!sp,      /* also Partneraddresse merken !      */
             tcb!da := tcp_in!sa;
      (FALSE):
      ENDDECISION;
      TASK rec_data!len := rec_data!len + tcp_in!len, /*Simulation des Empfangs- */
	   rec_data!fin := tcp_in!fin;    /* puffers, Speichern des Fin- Flags */
      CALL UpdateTCB(tcp_in);            /* Kontrollblock aktualisieren     */
      DECISION tcp_in!psh;
      (TRUE):
	 TASK rec_data!psh := TRUE,       /* Push-Flag speichern und Zeiger auf*/
	      rec_data!pshp := rec_data!len; /* Push-Daten aktualisieren       */
      (FALSE):
      ENDDECISION;
      DECISION tcp_in!urg;            
      (TRUE):
	TASK rec_data!urg := TRUE,      /* Urgent-Flag speichern und Zeiger   */
	     rec_data!urgp := rec_data!len; /* auf Urgent-Daten aktualisieren */
      (FALSE):
      ENDDECISION;
      CALL UpdateRetransmit(tcp_in);    /* Retransmit-Queue aktualisieren   */
      CALL DeliverData;                 /* Simulation der Datenuebergabe,   */
      RETURN;
ENDPROCEDURE;          

PROCEDURE CheckChecksum;                    /* Simulation der Pruefung der         */
FPAR tcp_in Tcp,                     /* Kontrollpruefsumme                  */
     IN/OUT ok Boolean;
START;
   DECISION tcp_in!len = tcp_in!cs;
   (TRUE):
	TASK ok := TRUE;
	RETURN;
   (FALSE):
	TASK ok := FALSE,
	     trace_block!bad_checksum := trace_block!bad_checksum + 1;
	RETURN;
   ENDDECISION;
ENDPROCEDURE CheckChecksum;

PROCEDURE CheckSynPacket;                    /* Prueftest fuer Verbindungsaufbau    */
FPAR tcp_in Tcp,
     IN/OUT ok Boolean;
START;
   DECISION (tcp_in!seq = tcb!rcv_nxt) AND (tcp_in!ack) AND
            (tcp_in!an=tcb!snd_nxt);
   (TRUE):
	TASK ok := TRUE;
	RETURN;
   (FALSE):
	TASK ok := FALSE;
	RETURN;
   ENDDECISION;
ENDPROCEDURE CheckSynPacket;

PROCEDURE CheckSequence;                  /* Prueftest waehrend der Verbindungs-   */
FPAR tcp_in Tcp,                   /* phase. Akzeptiert werden nur Pakete,  */
     IN/OUT ok Boolean;            /* deren Sequenznummer direkt mit der    */
START;                             /* erwarteten naechsten Nummer des       */
                                   /* Kontrollblocks uebereinstimmt !!!     */
   DECISION (((tcp_in!seq=tcb!rcv_nxt) AND (tcb!snd_nxt>=tcb!snd_una) AND 
   	      (tcp_in!an>=tcb!snd_una) AND (tcp_in!an<=tcb!snd_nxt) ) OR 
   	      ((tcp_in!seq=tcb!rcv_nxt) AND (tcb!snd_nxt<=tcb!snd_una) AND 
   	      ((tcp_in!an>=tcb!snd_una) OR (tcp_in!an<=tcb!snd_nxt) ) ));
   (TRUE):                        
	TASK ok := TRUE;
	RETURN;
   (FALSE):
	TASK ok := FALSE;
	OUTPUT err(tcb!sp, DEFAULT_ERROR) TO PARENT;  /* fuehrt nicht zu                  */
	RETURN;                          /* Programmabbruch !!               */
   ENDDECISION;
ENDPROCEDURE CheckSequence;

PROCEDURE IsReset;                /* prueft, ob Reset-Flag gesetzt ist und  */
FPAR tcp_in Tcp,                  /* das Paket zur laufenden Verbindung     */
     IN/OUT ok Boolean;           /* gehoert                                */
START;
   CALL CheckSequence(tcp_in,ok);
   DECISION tcp_in!rst AND ok;
   (TRUE):
	TASK ok := TRUE,
	     trace_block!is_reset := trace_block!is_reset + 1;
	OUTPUT err(tcb!sp,FATAL_ERROR) TO PARENT; 
	RETURN;
   (FALSE):
	TASK ok := FALSE;
	RETURN;
   ENDDECISION;
ENDPROCEDURE IsReset;

PROCEDURE InitRetransmitQueue;            /* initialisiert die Retransmit-Queue      */
FPAR first RetransmitRange;
START;
   jump1:
   DECISION first < BUFFER_SIZE;	  
   (TRUE):	        
      TASK retransmit_queue(first)!activ := FALSE,
           retransmit_queue(first)!tcp_packet!len := 0,
           retransmit_queue(first)!tcp_packet!cs := 0,
           retransmit_queue(first)!tcp_packet!syn := FALSE,
           retransmit_queue(first)!tcp_packet!ack := FALSE,
           retransmit_queue(first)!tcp_packet!fin := FALSE,
           retransmit_queue(first)!tcp_packet!rst := FALSE,
           first := first+1;
      join jump1;    
   (FALSE):
   ENDDECISION;
   RETURN;
ENDPROCEDURE InitRetransmitQueue;
      
   
PROCEDURE Init;                /* initialisiert Kontrollblock, soweit moegl. */
FPAR sp,dp,da,tout,toa,prec,sec Integer,
     psh,urg Boolean;
DCL first RetransmitRange;
START;
   TASK tcb!sp := sp,
   	tcb!dp := dp,
   	tcb!da := da;
   TASK tcb!tout := tout,
   	tcb!toa := toa,
   	tcb!prec := prec;
   TASK tcb!sec := sec,
   	tcb!psh := psh,
   	tcb!urg := urg,
   	tcb!snd_nxt := 0;
   TASK tcb!isn := 0,
   	oldest := 0,
   	first := 0;
   TASK tcb!snd_wnd := STANDARD,   /* damit bei AOD mind. ein Paket gesendet  */
        tcb!rcv_wnd := window_size, /*werden kann. Die Sendefenstergroesse ist*/
        rbuffer := 100 * STANDARD;  /* ja waehrend der Verbindung variabel und*/
   TASK tcb!snd_una := 0,         /* wird von Anwendungsschicht geregelt      */
        close_connection := FALSE,
        close_received := FALSE,
        fin_tmp := FALSE;
   TASK rec_data!len := 0,
        rec_data!urgp := 0,
        rec_data!pshp := 0,
        rec_data!fin := FALSE,
        rec_data!urg := FALSE,
        rec_data!psh := FALSE;
   TASK send_data!len := 0,
        send_data!urgp := 0,
        send_data!pshp := 0,
        send_data!fin := FALSE,
        send_data!urg := FALSE,
        send_data!psh := FALSE;
   CALL InitRetransmitQueue(first);      /* first ist Hilfsgroesse, um Rekursion zu   */
   RETURN;                      /* ermoeglichen                              */
ENDPROCEDURE Init;

PROCEDURE DeliverData;          /* Simulation der Uebergabe von Nutzdaten    */
START;                          /* an die Anwendungsschicht                  */
   DECISION rec_data!len = 0;   /* sind Empfangs-Daten gepuffert?            */
   (TRUE):
       RETURN;
   (FALSE):
      DECISION rbuffer >= rec_data!len;  /* reicht Uebergabepuffer fuer alle  */ 
      (TRUE):	                         /* Daten aus ?                       */
         OUTPUT del(tcb!sp,rec_data!len,rec_data!urg) TO PARENT;
         TASK rbuffer := rbuffer-rec_data!len,
           tcb!rcv_wnd := tcb!rcv_wnd + rec_data!len, /* Empfangsfenster    */
           rec_data!urg := FALSE,                       /* oeffnen            */
           rec_data!psh := FALSE,
           rec_data!urgp := 0,
           rec_data!pshp := 0,
	   rec_data!len := 0;
         RETURN;
      (FALSE):       /* Empfangsfenster ist zu klein fuer alle Daten, also  */
                     /* pruefen, ob alle wichtigen Daten uebergeben werden  */ 
         DECISION (rec_data!psh AND (rec_data!pshp<=rbuffer));  /* koennen  */
         (TRUE):	       /*  alle Push-Daten uebergeben               */
            OUTPUT del(tcb!sp,rec_data!pshp,TRUE) TO PARENT;
            DECISION rec_data!urgp >= rec_data!pshp;
            (TRUE):
               TASK rec_data!urgp := rec_data!urgp-rec_data!pshp;
            (FALSE):
               TASK rec_data!urgp := 0,
                  rec_data!urg := FALSE;
            ENDDECISION;
            TASK rbuffer := rbuffer-rec_data!pshp,
              tcb!rcv_wnd := tcb!rcv_wnd + rec_data!pshp,
              rec_data!len := rec_data!len-rec_data!pshp,
              rec_data!psh := FALSE,
              rec_data!pshp := 0;
            RETURN;
         (FALSE):
         ENDDECISION;
      ENDDECISION;
   ENDDECISION;
   RETURN;
ENDPROCEDURE DeliverData;        
      
PROCEDURE IsLastAck;             /* prueft, ob das Paket die Bestaetigung  */
FPAR tcp_in Tcp,                   /* unseres FIN-Paketes ist                */
   IN/OUT ok Boolean;
START;
   DECISION (tcp_in!an=tcb!snd_nxt AND tcp_in!ack);
   (TRUE):
      TASK ok := TRUE;
   (FALSE):
      TASK ok := FALSE;
   ENDDECISION;
   RETURN;
ENDPROCEDURE IsLastAck;    
           
PROCEDURE SendPacket;       /* IP bekommt nur sporadische Fuktionalitaet    */
FPAR tcp_in Tcp;             /* ein von TCP uebergebenes Paket wird ein ein  */
DCL ip_out Ip;               /* Datagramm gestopft und an die Mediumsschicht */
SYNONYM STANDARD_IP_SIZE Integer = 20;
SYNONYM STANDARD_IP_PROTECTION Integer = 0;
SYNONYM STANDARD_IP_TOS Integer = 0;
SYNONYM STANDARD_IP_TTL Integer = 10;
SYNONYM STANDARD_IP_ID Integer = 0;
SYNONYM STANDARD_IP_DF Boolean = TRUE;
START;                       /* weitergegeben                                */
    TASK tcp_in!sa := OWN_ADDRESS,
    	 ip_out!data := tcp_in,
         ip_out!len := tcp_in!len + STANDARD_IP_SIZE;
    TASK ip_out!src := tcp_in!sa,
         ip_out!dst := tcp_in!da,
         ip_out!cs  := ip_out!len;
    TASK ip_out!prot := STANDARD_IP_PROTECTION,	
         ip_out!tos :=  STANDARD_IP_TOS,	
         ip_out!ttl := STANDARD_IP_TTL;	
    TASK ip_out!id := STANDARD_IP_ID,	/* wegen Verzicht auf Fragmentierung */
         ip_out!df := STANDARD_IP_DF;   /* nicht noetig                                   */                                           
    OUTPUT ip_packet(ip_out) VIA LowerSAP;
    RETURN;
ENDPROCEDURE SendPacket;

PROCEDURE  Deliver;        /* IP-Funktionalitaet bei Eintreffen eines Data- */
FPAR ip_in Ip;             /* gramms, ebenfalls nur sporadisch              */
START;
    DECISION (ip_in!dst = OWN_ADDRESS);
    (FALSE):		/* dann Routing des Datagrammes, nicht implementiert */
       /* TASK ttl := ttl-1;
        DECISION (ttl > 0);
        (TRUE):	   Weitergabe durch Aufruf der Routingfunktion, ... 
        	   	
        (FALSE):	 dann zertoere Datagramm 
            RETURN;
        ENDDECISION; */
    (TRUE):
    ENDDECISION;
    DECISION (ip_in!len /= ip_in!cs) ;
    (TRUE):	/* physikalischer Uebertragungsfehler entdeckt	*/
    (FALSE):	/* Uebertragung korrekt, also mit Parametern weitergeben	*/
        OUTPUT tcp_packet(ip_in!data) VIA UpperSAP;
    ENDDECISION;
    RETURN;
ENDPROCEDURE Deliver; 

/* PROCESS Quelle(0, MAX_CONNECTIONS);


  SYNONYM scalereal = external;
  SYNONYM lambda real = external;
  SYNONYM burst  real = external;
  SYNONYM minarr integer = external;
  SYNONYM maxarr integer = external;
  PROCEDURE Sended  REFERENCED;
  
  DCL    arrival negexp,
         nextsig real,
         mueoff  real,
         tooff   negexp,
         nextoff real,
         mueon   real,
         toon    negexp,
         bulk    randint,
         bulknumber  integer,
         nexton  real;
  TIMER  packtime, ontime, offtime;
     
  START;
  TASK mueon   := (1.0 / (burst -1.0)),
       mueoff  := 1.0,
       arrival := init(arrival,lambda),
       tooff   := init(tooff,scale * mueoff),
       toon    := init(toon,scale * mueon),
       bulk    := init(bulk,minarr,maxarr),
       nexton  := sample(toon);
  SET(now + duration!(nexton),ontime);
  NEXTSTATE Off;
      
  STATE Off;
    INPUT ontime;
      TASK nextoff := sample(tooff),
           nextsig := sample(arrival);
      SET(now + duration!(nextoff),offtime);
      SET(now + duration!(nextsig),packtime);
      NEXTSTATE On;
      
  STATE On;
    INPUT packtime;
      TASK nextsig := sample(arrival),
           bulknumber  := sample(bulk);
           CALL Sended(bulknumber);
      SET(now + duration!(nextsig),packtime);    
      NEXTSTATE -;
      
   INPUT offtime;
     RESET(packtime);
     TASK nexton := sample(toon);
     SET(now + duration!(nexton),ontime);
     NEXTSTATE Off;
     
      
  STATE *;
     INPUT kill;
       RESET(packtime);
       RESET(offtime);
       RESET(ontime);
       STOP;

ENDPROCESS;
    
     
PROCEDURE Sended;
FPAR IN  d INTEGER;
       
DCL ab INTEGER;
    
START;
  TASK ab := 0;
  NEXTSTATE r;
    
  STATE r;
    INPUT none;
      DECISION ab = d;
        (true)  : return;
        (false) : OUTPUT send_init TO PARENT;
                  TASK ab := ab + 1;
                  NEXTSTATE -;
      ENDDECISION;
ENDPROCEDURE; */

